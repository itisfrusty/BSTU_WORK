# Huffman-coding
### Кодирование Хаффмана на С++

*"Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы. В настоящее время используется во многих программах сжатия данных."* - общее описание алгоритма из wiki.

Интерфейс (*visual studio 2015*):

![alt tag](https://raw.githubusercontent.com/manmolecular/Huffman-coding/master/interface-screenshot.PNG)
![alt tag](https://raw.githubusercontent.com/manmolecular/Huffman-coding/master/interface_screenshot_1.PNG)
![alt tag](https://raw.githubusercontent.com/manmolecular/Huffman-coding/master/interface_screenshot_2.PNG)

Проверка хешей входного и выходного файлов:

![alt tag](https://raw.githubusercontent.com/manmolecular/Huffman-coding/master/hash_screenshot.PNG)


### Общий принцип (алгоритм) работы:
#### Кодирование:
1. На вход программы поступает текст - вводится либо с клавиатуры (функция *get_input*), либо из файла (функция *get_data*).
2. Из полученного текста создается алфавит - массив символов, исключающий повторы (функция *get_repeat*).
3. Создается массив частот (размер которого равен размеру алфавита) для символов из алфавита (функция *get_frequency*).
4. Из полученного массива частот и алфавита строится дерево Хаффмана (функция *HuffmanCodes*).
5. Из полученного на предыдущем шаге дерева строится строка, где каждый символ заменен на соответствующий ему код (функция *encode_text*).
6. С помощью функции *get_encode* строка возвращается из класса в виде объекта типа string, который является закодированным начальным текстом. 

#### Раскодирование:
1. На вход поступает строка, состоящая из закодированных символов (т.е. кодовая строка из 0 и 1).
2. Функция *decode_text* обходит полученное на этапе кодирования дерево, сравнивая каждый символ в строке с 0 и 1:
  * Если текущий символ в строке 0, уходим от текущего узла влево.
  * Если текущий символ в строке 1, уходим от текущего узла вправо.
3. Как только попадаем в конечный лист, записываем в строку символ, лежащий в поле *data* текущего узла.
Таким образом, каждый раз проходя от *root* узла дерева, "собираем" исходное сообщение в единую строку.

### Структура класса huffman_coding
		struct compare{};                                                     // Структура для сравнения
		void printCodes(huffman_tree_node* root, string str);                 // Печать кодов
		void HuffmanCodes(char data[], int freq[], int size);                 // Кодирование
		void print_map();                                                     // Вывод мапы для проверки
		void encode_text(string text);                                        // Кодирование-замена в самой стринге
		string get_encode();                                                  // Возврат encode строки
		void output_in_file();                                                // Вывод в файл
		void decode_text_from_map(string text);                               // Раскодирование через map (пробное)
		string decode_text(string str);                                       // Раскодирование через дерево
